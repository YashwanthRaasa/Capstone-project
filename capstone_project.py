# -*- coding: utf-8 -*-
"""Capstone_project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10PVAkt10SVRmUvg9kh_92MJ0lJiipQ9T
"""

import pandas as pd

# Load the dataset
df = pd.read_csv("dataset.csv")

# Show first 5 rows
df.head()

# Load your dataset
df.columns

# Set base price and alpha
BASE_PRICE = 10
ALPHA = 5

# Model 1: Price increases linearly with occupancy
df['Model1_Price'] = BASE_PRICE + ALPHA * (df['Occupancy'] / df['Capacity'])

# Show result
df[['Occupancy', 'Capacity', 'Model1_Price']].head()

# Model 2 – Demand-Based Pricing
# Encode vehicle type (weights)
vehicle_weights = {
    'car': 1.0,
    'bike': 0.5,
    'truck': 1.5
}

# Add weight column
df['VehicleTypeWeight'] = df['VehicleType'].map(vehicle_weights)

# Encode TrafficConditionNearby
traffic_mapping = {
    'low': 1,
    'average': 2,
    'high': 3
}

df['TrafficLevel'] = df['TrafficConditionNearby'].map(traffic_mapping)

df[['TrafficConditionNearby', 'TrafficLevel']]

# Set coefficients (you can tune these)
alpha = 2
beta = 1.5
gamma = 1.2
delta = 1.0
epsilon = 1.0
lambd = 0.5  # λ for price scaling

# Raw demand formula
df['RawDemand'] = (
    alpha * (df['Occupancy'] / df['Capacity']) +
    beta * df['QueueLength'] -
    gamma * df['TrafficLevel'] +
    delta * df['IsSpecialDay'] +
    epsilon * df['VehicleTypeWeight']
)

# Normalize Demand to 0-1 (min-max scaling)
dmin = df['RawDemand'].min()
dmax = df['RawDemand'].max()
df['NormalizedDemand'] = (df['RawDemand'] - dmin) / (dmax - dmin)

# Calculate price using demand
df['Model2_Price'] = BASE_PRICE * (1 + lambd * df['NormalizedDemand'])

# Clamp price between 0.5x and 2x base price
df['Model2_Price'] = df['Model2_Price'].clip(lower=BASE_PRICE * 0.5, upper=BASE_PRICE * 2.0)

# Show results
df[['Occupancy', 'QueueLength', 'TrafficLevel', 'VehicleType', 'Model2_Price']].head()

df.columns

!pip install bokeh --quiet

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource
from bokeh.layouts import column
import pandas as pd

output_notebook()

# Sort by Occupancy for cleaner curves
df_sorted = df.sort_values(by='Occupancy').reset_index(drop=True)

# Smoothing using rolling mean (window size = 50, tune as needed)
df_sorted['Model1_Price_Smooth'] = df_sorted['Model1_Price'].rolling(window=50, min_periods=1).mean()
df_sorted['Model2_Price_Smooth'] = df_sorted['Model2_Price'].rolling(window=50, min_periods=1).mean()

# Data source
source = ColumnDataSource(data={
    'Occupancy': df_sorted['Occupancy'],
    'Model1_Price': df_sorted['Model1_Price_Smooth'],
    'Model2_Price': df_sorted['Model2_Price_Smooth']
})

# Create Bokeh figure
p = figure(title="Dynamic Pricing Comparison (Smoothed + Transparent)",
           x_axis_label="Occupancy",
           y_axis_label="Price ($)",
           width=800, height=400)

# Add lines with smoothing + transparency
p.line('Occupancy', 'Model1_Price', source=source, legend_label="Model 1: Linear",
       line_width=2, color='blue', alpha=0.6)

p.line('Occupancy', 'Model2_Price', source=source, legend_label="Model 2: Demand-Based",
       line_width=2, color='green', alpha=0.4)

# Style
p.legend.location = "top_left"
p.grid.grid_line_alpha = 0.3

# Show plot
show(p)

# Create a fake Time and LotID column for simulation
df['Time'] = pd.date_range(start='2025-01-01 08:00', periods=len(df), freq='30T')
df['LotID'] = 'Lot_A'  # You can randomize this for multiple lots

# Filter for one lot
lot_df = df[df['LotID'] == 'Lot_A'].copy()
lot_df = lot_df.sort_values(by='Time').reset_index(drop=True)

source = ColumnDataSource(data={'Time': [], 'Price': []})

p = figure(title="Real-Time Price Updates for Lot A",
           x_axis_type='datetime', width=800, height=400)
p.line(x='Time', y='Price', source=source, line_width=2, color='blue', legend_label="Model 2 Price")

handle = show(p, notebook_handle=True)

import pandas as pd
# Simulate a time column (30-minute intervals)
df['Time'] = pd.date_range(start='2025-01-01 08:00', periods=len(df), freq='30min')

# Simulate a single parking lot
df['LotID'] = 'Lot_A'

# Filter for one lot and sort by time
lot_df = df[df['LotID'] == 'Lot_A'].sort_values(by='Time').reset_index(drop=True)

from bokeh.models import ColumnDataSource

output_notebook()

source = ColumnDataSource(lot_df)

p = figure(title="Model 2 Price Over Time – Lot A",
           x_axis_type='datetime',
           x_axis_label="Time",
           y_axis_label="Model 2 Price ($)",
           width=800, height=400)

p.line(x='Time', y='Model2_Price', source=source, line_width=2, color='green', legend_label="Lot A")


show(p)

from bokeh.plotting import figure, show, output_notebook
from bokeh.models import ColumnDataSource

output_notebook()

# Optional: smooth Model 1 price
lot_df['Smooth_Model1'] = lot_df['Model1_Price'].rolling(window=20, min_periods=1).mean()

source = ColumnDataSource(lot_df)

p = figure(title="Model 1 Price Over Time – Lot A",
           x_axis_type='datetime',
           x_axis_label="Time",
           y_axis_label="Model 1 Price ($)",
           width=800, height=400)

p.line(x='Time', y='Smooth_Model1', source=source, line_width=2, color='blue', legend_label="Lot A")

show(p)

!pip install pathway --quiet
import pathway as pw

# Define a Schema for the CSV
['Occupancy', 'Capacity', 'QueueLength', 'TrafficConditionNearby', 'IsSpecialDay', 'VehicleType']

class ParkingSchema(pw.Schema):
    Occupancy: int
    Capacity: int
    QueueLength: int
    TrafficConditionNearby: str
    IsSpecialDay: int
    VehicleType: str

# Define Mapping Functions First
# We'll reuse your Model 2 demand function, but in pure Python:
@pw.udf
def calculate_model2_price(occupancy, capacity, queue, traffic, is_special, vehicle_type):
    # Map traffic
    traffic_map = {'low': 1, 'average': 2, 'high': 3}
    vehicle_map = {'car': 1.0, 'bike': 0.5, 'truck': 1.5}

    traffic_level = traffic_map.get(traffic.lower(), 2)
    vehicle_weight = vehicle_map.get(vehicle_type.lower(), 1.0)

    # Demand formula
    alpha = 2
    beta = 1.5
    gamma = 1.2
    delta = 1.0
    epsilon = 1.0
    lambd = 0.5
    base_price = 10

    raw_demand = (
        alpha * (occupancy / capacity) +
        beta * queue -
        gamma * traffic_level +
        delta * is_special +
        epsilon * vehicle_weight
    )

    # Normalize (skip scaling step for simplicity here)
    demand = max(0, min(raw_demand / 10, 1))  # Simple bounded normalization

    price = base_price * (1 + lambd * demand)
    return min(max(price, base_price * 0.5), base_price * 2.0)

# Build the Pathway Pipeline
input_table = pw.io.csv.read("dataset.csv", schema=ParkingSchema,mode="static")

result_table = input_table.select(
    Occupancy=input_table.Occupancy,
    Capacity=input_table.Capacity,
    QueueLength=input_table.QueueLength,
    Traffic=input_table.TrafficConditionNearby,
    Vehicle=input_table.VehicleType,
    IsSpecial=input_table.IsSpecialDay,
    Model2_Price=calculate_model2_price(
        input_table.Occupancy,
        input_table.Capacity,
        input_table.QueueLength,
        input_table.TrafficConditionNearby,
        input_table.IsSpecialDay,
        input_table.VehicleType
    )
)

output_table = result_table  # or rename if needed

pw.io.csv.write(
    table=result_table,
    filename="model2_output.csv"
)

pw.run()

import pandas as pd

df = pd.read_csv("model2_output.csv")
df.head()

# Model1_Price = BasePrice + α * (Occupancy / Capacity)

@pw.udf
def calculate_model1_price(occupancy, capacity):
    base_price = 10
    alpha = 5
    return base_price + alpha * (occupancy / capacity)

result_table = input_table.select(
    Occupancy=input_table.Occupancy,
    Capacity=input_table.Capacity,
    QueueLength=input_table.QueueLength,
    Traffic=input_table.TrafficConditionNearby,
    Vehicle=input_table.VehicleType,
    IsSpecial=input_table.IsSpecialDay,
    Model1_Price=calculate_model1_price(
        input_table.Occupancy,
        input_table.Capacity
    ),
    Model2_Price=calculate_model2_price(
        input_table.Occupancy,
        input_table.Capacity,
        input_table.QueueLength,
        input_table.TrafficConditionNearby,
        input_table.IsSpecialDay,
        input_table.VehicleType
    )
)

pw.io.csv.write(
    table=result_table,
    filename="final_output.csv"
)

pw.run()

import pandas as pd

df = pd.read_csv("final_output.csv")
df[['Occupancy', 'Capacity', 'Model1_Price', 'Model2_Price']].head()

!git clone https://github.com/YashwanthRaasa/Capstone-project.git